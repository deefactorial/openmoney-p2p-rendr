{
  "name": "memo-is",
  "version": "0.0.2",
  "homepage": "https://github.com/d11wtq/memo-is",
  "description": "Memoization for Mocha/Jasmine specs (like RSpec's #let)",
  "author": {
    "name": "Chris Corbyn",
    "email": "chris@w3style.co.uk"
  },
  "maintainers": [
    {
      "name": "d11wtq",
      "email": "chris@w3style.co.uk"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/d11wtq/node-memo-is.git"
  },
  "files": [
    "lib",
    "README.md",
    "LICENSE"
  ],
  "devDependencies": {
    "mocha": ""
  },
  "scripts": {},
  "keywords": [
    "spec",
    "mocha",
    "jasmine",
    "memoize"
  ],
  "main": "./lib/memo-is",
  "license": "MIT",
  "readme": "# Memoization, like RSpec let for Node.js & Mocha/Jasmine\n\nmemo-is provides a memoization system with the same semantics as `#let` in\nRSpec for Ruby. It allows you to provide a function that should be memoized\nfor the duration of a spec example and reset between examples. It also\nsupports nested overriding, as expected.\n\nIt will work with Jasmine and Mocha out of the box, since it only needs to\nhook into `beforeEach()` and `afterEach()` hooks to work. It may work with\nother testing frameworks (e.g. vows) if you can provide implementations of\n`beforeEach()` and `afterEach()` to do the correct thing.\n\n## Installation\n\nThis should work just fine in a browser, if you include the lib/memo-is.js\nfile via a `<script>` tag. For Node.js, you can install it via NPM:\n\n    npm install memo-is\n\n## Usage\n\nWhat better way to document this usage than with a spec? :-) This is the\nactual spec from the package itself.\n\n``` javascript\nvar memo   = require('memo-is')\n  , assert = require('assert')\n  ;\n\ndescribe('Memoizer', function(){\n  var example = memo().is(function() { return []; });\n  var value;\n\n  beforeEach(function() { value = example(); });\n\n  it('returns the same value every time', function(){\n    assert(example() === example());\n  });\n\n  describe('when overridden', function(){\n    example.is(function() { return ['bob']; });\n\n    it('returns the overridden value', function(){\n      assert.equal(example()[0], 'bob');\n    });\n\n    it('is available in the before of an outer context', function(){\n      assert.equal(value[0], 'bob');\n    });\n\n    describe('and used in a sub context', function(){\n      it('returns the overridden value', function(){\n        assert.equal(example()[0], 'bob');\n      });\n    });\n  });\n\n  describe('state between tests', function(){\n    it('is reset to the value for the current context', function(){\n      assert.equal(example().length, 0);\n    });\n\n    describe('when the value is modified', function(){\n      it('is changed in the example that modifies it', function(){\n        example().push(42);\n        assert.equal(example()[0], 42);\n      });\n\n      it('is reset between examples', function(){\n        assert.equal(example().length, 0);\n      });\n    });\n  });\n});\n```\n\n## Caveats\n\nOne thing you should be aware of is the fact that memo-is depends on the\n`before()` hook in order to prepare the memoized function. When working with\nthe memoized function inside a `beforeEach()`, you won't have any unexpected\nissues. When working with it inside a `before()` hook of a context nested\ndeeper than where the memoized function is defined, you won't have any issues\nneither. When working, however, with a `before()` hook in the same context as\nwhere you define the memoized function, you *must* define the memoizer first,\nso that it is available in your `before()` hook.\n\nThis is fine:\n\n``` javascript\ndescribe('using inside a before()', function(){\n  var numPlusOne;\n  var example = memo().is(function(){ return 42; });\n\n  before(function() { numPlusOne = example() + 1; }\n\n  it('works when the hook is declared after the memoizer', function(){\n    assert.equal(numPlusOne, 43);\n  });\n});\n```\n\nThis won't work:\n\n``` javascript\ndescribe('using inside a before()', function(){\n  var numPlusOne;\n\n  before(function() { numPlusOne = example() + 1; }\n\n  var example = memo().is(function(){ return 42; }); // too late!\n\n  it('explodes in an unexpected way', function(){\n    assert.equal(numPlusOne, 43);\n  });\n});\n```\n\nThe same applies for overriding memoizer functionsâ€”do the override first.\n\nIf anybody can think of a way to remove this limitation, please send a pull\nrequest :-)\n\n## Copyright & Licensing\n\nWritten and maintained by Chris Corbyn. Licensed under the MIT license.\nSee the LICENSE file for details.\n",
  "_id": "memo-is@0.0.2",
  "dist": {
    "shasum": "5bb811cbe81263dffba49b3cd52c6434f212c5a2",
    "tarball": "http://registry.npmjs.org/memo-is/-/memo-is-0.0.2.tgz"
  },
  "directories": {},
  "_shasum": "5bb811cbe81263dffba49b3cd52c6434f212c5a2",
  "_resolved": "https://registry.npmjs.org/memo-is/-/memo-is-0.0.2.tgz",
  "_from": "memo-is@0.0.2"
}
